// Code generated by goppy-cli for goppy.orm. DO NOT EDIT.
package entity

import (
	"context"
	time "time"

	uuid "github.com/google/uuid"
	"go.osspkg.com/goppy/v2/orm"
)

const sqlCreateAuth = `INSERT INTO "auth" ("token", "domains", "locked", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5);`

func (v *Repo) CreateBulkAuth(ctx context.Context, ms []Auth, opts ...CreateOption) error {
	if len(ms) == 0 {
		return nil
	}
	for _, m := range ms {
		m.CreatedAt = time.Now()
	}
	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()
	buf.WriteString(sqlCreateAuth)
	for _, o := range opts {
		o(buf)
	}
	buf.WriteString(` RETURNING ("id");`)
	return v.Master().Tx(ctx, "auth_create_bulk", func(tx orm.Tx) {
		for _, m := range ms {
			tx.Query(func(q orm.Querier) {
				q.SQL(buf.String(), m.Token, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt)
				q.Bind(func(bind orm.Scanner) error {
					return bind.Scan(&m.ID)
				})
			})
		}
	})
}
func (v *Repo) CreateAuth(ctx context.Context, m Auth, opts ...CreateOption) error {
	m.CreatedAt = time.Now()
	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()
	buf.WriteString(sqlCreateAuth)
	for _, o := range opts {
		o(buf)
	}
	buf.WriteString(` RETURNING ("id");`)
	return v.Master().Query(ctx, "auth_create", func(q orm.Querier) {
		q.SQL(buf.String(), m.Token, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt)
		q.Bind(func(bind orm.Scanner) error {
			return bind.Scan(&m.ID)
		})
	})
}

const sqlSelectCursorAuth = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "id">$1 ORDER BY "id" LIMIT $2;`

func (v *Repo) SelectAuthCursor(ctx context.Context, from int64, lim uint) ([]Auth, error) {
	result := make([]Auth, 0, lim)
	err := v.Sync().Query(ctx, "auth_read_all", func(q orm.Querier) {
		q.SQL(sqlSelectCursorAuth, from, lim)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByID = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "id"=ANY($1);`

func (v *Repo) SelectAuthByID(ctx context.Context, args ...int64) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_id", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByID, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByToken = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "token"=ANY($1);`

func (v *Repo) SelectAuthByToken(ctx context.Context, args ...uuid.UUID) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_token", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByToken, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByDomains = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "domains"=ANY($1);`

func (v *Repo) SelectAuthByDomains(ctx context.Context, args ...string) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_domains", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByDomains, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByLocked = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "locked"=ANY($1);`

func (v *Repo) SelectAuthByLocked(ctx context.Context, args ...bool) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_locked", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByLocked, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByCreatedAt = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "created_at"=ANY($1);`

func (v *Repo) SelectAuthByCreatedAt(ctx context.Context, args ...time.Time) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_created_at", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByCreatedAt, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByUpdatedAt = `SELECT "id", "token", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "updated_at"=ANY($1);`

func (v *Repo) SelectAuthByUpdatedAt(ctx context.Context, args ...time.Time) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_updated_at", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByUpdatedAt, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.Token, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlUpdateAuthByID = `UPDATE "auth" SET "created_at"=$4, "domains"=$2, "locked"=$3, "token"=$1, "updated_at"=$5 WHERE "id"=$6;`

func (v *Repo) UpdateAuthByID(ctx context.Context, ms ...Auth) error {
	if len(ms) == 0 {
		return nil
	}
	for _, m := range ms {
		m.UpdatedAt = time.Now()
	}
	if len(ms) == 1 {
		return v.Master().Exec(ctx, "auth_update_by_id", func(e orm.Executor) {
			e.SQL(sqlUpdateAuthByID, ms[0].Token, ms[0].Domains, ms[0].Locked, ms[0].CreatedAt, ms[0].UpdatedAt, ms[0].ID)
		})
	}
	return v.Master().Tx(ctx, "auth_update_bulk_by_id", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlUpdateAuthByID)
			for _, m := range ms {
				e.Params(m.Token, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt, m.ID)
			}
		})
	})
}

const sqlDeleteAuthByID = `DELETE FROM "auth" WHERE "id"=ANY($1);`

func (v *Repo) DeleteAuthByID(ctx context.Context, ms ...int64) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_id", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByID, ms)
		})
	})
}

const sqlDeleteAuthByToken = `DELETE FROM "auth" WHERE "token"=ANY($1);`

func (v *Repo) DeleteAuthByToken(ctx context.Context, ms ...uuid.UUID) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_token", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByToken, ms)
		})
	})
}

const sqlDeleteAuthByDomains = `DELETE FROM "auth" WHERE "domains"=ANY($1);`

func (v *Repo) DeleteAuthByDomains(ctx context.Context, ms ...string) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_domains", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByDomains, ms)
		})
	})
}

const sqlDeleteAuthByLocked = `DELETE FROM "auth" WHERE "locked"=ANY($1);`

func (v *Repo) DeleteAuthByLocked(ctx context.Context, ms ...bool) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_locked", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByLocked, ms)
		})
	})
}

const sqlDeleteAuthByCreatedAt = `DELETE FROM "auth" WHERE "created_at"=ANY($1);`

func (v *Repo) DeleteAuthByCreatedAt(ctx context.Context, ms ...time.Time) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_created_at", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByCreatedAt, ms)
		})
	})
}

const sqlDeleteAuthByUpdatedAt = `DELETE FROM "auth" WHERE "updated_at"=ANY($1);`

func (v *Repo) DeleteAuthByUpdatedAt(ctx context.Context, ms ...time.Time) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_updated_at", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByUpdatedAt, ms)
		})
	})
}
