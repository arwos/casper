// Code generated by goppy-cli for goppy.orm. DO NOT EDIT.
package entity

import (
	"context"
	time "time"

	uuid "github.com/google/uuid"
	"go.osspkg.com/goppy/v2/orm"
)

const sqlCreateAuth = `INSERT INTO "auth" ("token_id", "token_key", "domains", "locked", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6)`

func (v *Repo) CreateBulkAuth(ctx context.Context, ms []*Auth, opts ...CreateOption) error {
	if len(ms) == 0 {
		return nil
	}
	for _, m := range ms {
		m.CreatedAt = time.Now()
	}
	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()
	buf.WriteString(sqlCreateAuth)
	for _, o := range opts {
		o(buf)
	}
	buf.WriteString(` RETURNING ("id")`)
	buf.WriteString(";")
	return v.Master().Tx(ctx, "auth_create_bulk", func(tx orm.Tx) {
		for _, m := range ms {
			tx.Query(func(q orm.Querier) {
				q.SQL(buf.String(), m.TokenId, m.TokenKey, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt)
				q.Bind(func(bind orm.Scanner) error {
					return bind.Scan(&m.ID)
				})
			})
		}
	})
}
func (v *Repo) CreateAuth(ctx context.Context, m *Auth, opts ...CreateOption) error {
	m.CreatedAt = time.Now()
	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()
	buf.WriteString(sqlCreateAuth)
	for _, o := range opts {
		o(buf)
	}
	buf.WriteString(` RETURNING ("id")`)
	buf.WriteString(";")
	return v.Master().Query(ctx, "auth_create", func(q orm.Querier) {
		q.SQL(buf.String(), m.TokenId, m.TokenKey, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt)
		q.Bind(func(bind orm.Scanner) error {
			return bind.Scan(&m.ID)
		})
	})
}

const sqlSelectCursorAuth = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "id">$1 ORDER BY "id" LIMIT $2;`

func (v *Repo) SelectAuthCursor(ctx context.Context, from int64, lim uint) ([]Auth, error) {
	result := make([]Auth, 0, lim)
	err := v.Sync().Query(ctx, "auth_read_all", func(q orm.Querier) {
		q.SQL(sqlSelectCursorAuth, from, lim)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByID = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "id"=ANY($1);`

func (v *Repo) SelectAuthByID(ctx context.Context, args ...int64) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_id", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByID, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByTokenId = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "token_id"=ANY($1);`

func (v *Repo) SelectAuthByTokenId(ctx context.Context, args ...uuid.UUID) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_token_id", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByTokenId, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByTokenKey = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "token_key"=ANY($1);`

func (v *Repo) SelectAuthByTokenKey(ctx context.Context, args ...string) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_token_key", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByTokenKey, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByDomains = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "domains"=ANY($1);`

func (v *Repo) SelectAuthByDomains(ctx context.Context, args ...string) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_domains", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByDomains, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByLocked = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "locked"=ANY($1);`

func (v *Repo) SelectAuthByLocked(ctx context.Context, args ...bool) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_locked", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByLocked, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByCreatedAt = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "created_at"=ANY($1);`

func (v *Repo) SelectAuthByCreatedAt(ctx context.Context, args ...time.Time) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_created_at", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByCreatedAt, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlSelectAuthByUpdatedAt = `SELECT "id", "token_id", "token_key", "domains", "locked", "created_at", "updated_at" FROM "auth" WHERE "updated_at"=ANY($1);`

func (v *Repo) SelectAuthByUpdatedAt(ctx context.Context, args ...time.Time) ([]Auth, error) {
	if len(args) == 0 {
		return nil, nil
	}
	result := make([]Auth, 0, len(args))
	err := v.Sync().Query(ctx, "auth_read_by_updated_at", func(q orm.Querier) {
		q.SQL(sqlSelectAuthByUpdatedAt, args)
		q.Bind(func(bind orm.Scanner) error {
			m := Auth{}
			if e := bind.Scan(&m.ID, &m.TokenId, &m.TokenKey, &m.Domains, &m.Locked, &m.CreatedAt, &m.UpdatedAt); e != nil {
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err != nil {
		return nil, err
	}
	return result, nil
}

const sqlUpdateAuthByID = `UPDATE "auth" SET "created_at"=$5, "domains"=$3, "locked"=$4, "token_id"=$1, "token_key"=$2, "updated_at"=$6 WHERE "id"=$7;`

func (v *Repo) UpdateAuthByID(ctx context.Context, ms ...*Auth) error {
	if len(ms) == 0 {
		return nil
	}
	for _, m := range ms {
		m.UpdatedAt = time.Now()
	}
	if len(ms) == 1 {
		return v.Master().Exec(ctx, "auth_update_by_id", func(e orm.Executor) {
			e.SQL(sqlUpdateAuthByID, ms[0].TokenId, ms[0].TokenKey, ms[0].Domains, ms[0].Locked, ms[0].CreatedAt, ms[0].UpdatedAt, ms[0].ID)
		})
	}
	return v.Master().Tx(ctx, "auth_update_bulk_by_id", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlUpdateAuthByID)
			for _, m := range ms {
				e.Params(m.TokenId, m.TokenKey, m.Domains, m.Locked, m.CreatedAt, m.UpdatedAt, m.ID)
			}
		})
	})
}

const sqlDeleteAuthByID = `DELETE FROM "auth" WHERE "id"=ANY($1);`

func (v *Repo) DeleteAuthByID(ctx context.Context, ms ...int64) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_id", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByID, ms)
		})
	})
}

const sqlDeleteAuthByTokenId = `DELETE FROM "auth" WHERE "token_id"=ANY($1);`

func (v *Repo) DeleteAuthByTokenId(ctx context.Context, ms ...uuid.UUID) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_token_id", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByTokenId, ms)
		})
	})
}

const sqlDeleteAuthByTokenKey = `DELETE FROM "auth" WHERE "token_key"=ANY($1);`

func (v *Repo) DeleteAuthByTokenKey(ctx context.Context, ms ...string) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_token_key", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByTokenKey, ms)
		})
	})
}

const sqlDeleteAuthByDomains = `DELETE FROM "auth" WHERE "domains"=ANY($1);`

func (v *Repo) DeleteAuthByDomains(ctx context.Context, ms ...string) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_domains", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByDomains, ms)
		})
	})
}

const sqlDeleteAuthByLocked = `DELETE FROM "auth" WHERE "locked"=ANY($1);`

func (v *Repo) DeleteAuthByLocked(ctx context.Context, ms ...bool) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_locked", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByLocked, ms)
		})
	})
}

const sqlDeleteAuthByCreatedAt = `DELETE FROM "auth" WHERE "created_at"=ANY($1);`

func (v *Repo) DeleteAuthByCreatedAt(ctx context.Context, ms ...time.Time) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_created_at", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByCreatedAt, ms)
		})
	})
}

const sqlDeleteAuthByUpdatedAt = `DELETE FROM "auth" WHERE "updated_at"=ANY($1);`

func (v *Repo) DeleteAuthByUpdatedAt(ctx context.Context, ms ...time.Time) error {
	if len(ms) == 0 {
		return nil
	}
	return v.Master().Tx(ctx, "auth_delete_by_updated_at", func(tx orm.Tx) {
		tx.Exec(func(e orm.Executor) {
			e.SQL(sqlDeleteAuthByUpdatedAt, ms)
		})
	})
}
